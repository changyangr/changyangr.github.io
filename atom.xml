<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-28T09:22:59.252Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>changyangr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重新做人之 pwn 栈溢出</title>
    <link href="http://example.com/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2021-10-28T06:27:45.000Z</published>
    <updated>2021-10-28T09:22:59.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2> <font color="red"> <p> 函数状态主要涉及三个寄存器－－esp，ebp，eip。<br> esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。<br> ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。<br> eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p><p> 这是一个栈：<br> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/zhan.jpg"><br> caller: 调用函数<br> callee: 被调用函数<br> 我们通过函数向栈里面写入的数据应是从 argn 开始，一路写进去，最后覆盖 callee 的 return address。<br> 所以一般的 payload= padding + (ebp) + (eip)<br> ebp 的覆盖一般来说可以任意。</p> </font><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="格式化字符串介绍"><a href="#格式化字符串介绍" class="headerlink" title="格式化字符串介绍"></a>格式化字符串介绍</h3> <font color="red"><pre><code>格式化字符串是一个使 printf 类函数 错误的漏洞，虽然利用方法（对我来说）较难，但是利用方式却多样。</code></pre> </font> <font color="Blue">  <p> 格式化字符串 漏洞 ：<br>    %x : 输出一个16进制数，前面没有 0x<br>    %p : 输出一个16进制数，前面带有 0x （一般来说，使用 %p 来泄露地址）<br>    %c : 写入一个字符，用来填充字符 如 %13c，经 printf 识别，就会写入13个字符。 劫持 got 表时，需要用到。<br>    %s : 输出一个字符串。 可以用来泄露地址。<br>    %n : 写入一个数字，且为已写入字符的数量，配合 %c 修改地址。<br>    （除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。）</p> </font> <font face="黑体" color="red" size="5"><p> 32位是通过堆栈传参<br> 64位是通过寄存器+堆栈传参，顺序依次是：rdi、rsi、rdx、rcx、r8、r9（edi、esi、edx、ecx、r8、r9）<br> 注意：<br> 我们向栈里写入的数据是先存放在栈上，后通过 printf 识别，再输出的。所以 本身的 %p 之类被识别的指令，也是会在栈上占据位置。 </p> </font> <font color="green"><p> 32位 格式化字符串漏洞的 got表 劫持：<br> offset = 5<br> payload=p32(got)+’%’+str(system-4)+’c%5$n’ 将got里存放的地址写为system的 地址。</p><p> 也可以这么写：<br> offset = 5<br> payload=p32(got)+p32(got+1)+p32(got+2)+p32(got+3)<br> payload+=’%’+str()+’c%5$hhn’<br> payload+=’%’+str()+’c%6$hhn’<br> payload+=’%’+str()+’c%7$hhn’<br> payload+=’%’+str()+’c%8$hhn’<br> 依照位次而定，每一个覆盖是2位。（因为无论是32位或是64位 汇编，都是小端序，所以需要倒着写）</p> </font> <font color="red"><p> 64位 格式化字符串漏洞的 got表 劫持：</p><p> 64位是通过寄存器+堆栈传参，顺序依次是：rdi、rsi、rdx、rcx、r8、r9（edi、esi、edx、ecx、r8、r9）</p><p> offset=6    一般情况下偏移为 6 或 7</p><p> 由于64位下用户可见的内存地址高位都带有\x00(64位地址共16个16进制数)，而 \x00 是字符串结束符。<br> 所以 应把要改 的 got表地址 放在后面，且不能用%hhn 分段写。<br> 如：<br> payload=’a%’+str(system-1)+’c%8$lln’+p64(got)     加 a 是为了使得数据在栈上对齐。</p> </font>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
